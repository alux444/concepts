---
title: Claude Prompt
description: My current CLAUDE.md for typescript
order: 1
---

```
---

TypeScript

- NEVER use any — use unknown, proper interfaces, or generics instead
- Strict mode always — no @ts-ignore, no @ts-expect-error
- Prefer interface over type for object shapes
- All function parameters and return types must be explicitly typed
- Define interfaces for external dependencies (databases, APIs, file systems, third-party
  libraries) — never depend on concrete implementations directly
- Use types to eliminate invalid states — don't use -1 or null with a comment explaining what it
  means. Use T | undefined, union types, or tagged unions so the compiler enforces correctness
  instead of a comment.

Functions

- Max 50 lines per function — no exceptions
- Extract helpers aggressively ("wishful thinking" style: write the high-level flow first calling
  functions that don't exist yet, then implement them)
- Each function does ONE thing
- Accept dependencies as parameters — functions should receive what they need, not construct or
  import it themselves
- Use factory functions when dependency selection depends on runtime context (user config,
  environment, file type, etc.)

Control Flow

- Early returns only — guard clause at the top, happy path at the bottom
- No nested if/else chains — invert conditions and return early
- No else after a return
- No if/else chains for selecting implementations — use an interface with multiple implementations
  and inject the right one

Naming

- NEVER abbreviate variable names. userMessage not usrMsg.
- Use units only where relevant (timeoutMs, fileSizeBytes)
- Extract magic values into named constants — if (status === MESSAGE_SENT) not if (status === 5)
- Complex conditions become named variables or functions — if a condition needs explanation, give
  it a name: const isEligibleForDiscount = ... or extract to isEligibleForDiscount()
- Code should read like prose — if you feel the urge to add a comment, rename things until the
  code says it itself

Style

- const by default, let only when mutation is required. Never var.
- Destructure parameters and objects
- Named exports only — no default exports (except route files for Express)
- NEVER make bundles of utils. Sort them into their own relevant modules / move into relevant
  class / make a new class if needed.

Comments

- Don't write comments — improve the code instead
- If a condition is complex enough to need a comment, extract it into a named variable or function
- If a value needs a comment to explain what it represents, make it a named constant or a type
- Exceptions: performance hacks that would look wrong without context, links to algorithms or
  papers the code implements
- API documentation is not a comment — document public interfaces, expected behavior, and error
  conditions with JSDoc. This describes how to use the code, not how it works internally.

Dependency Injection

- Constructor/parameter injection over global imports — pass dependencies in, don't reach out for
  them
- One interface per external boundary — wrap third-party libraries and external services behind
  your own interfaces
- Composition at the entry point — wire up all dependencies in one place (factory or main), not
  scattered across the codebase
- No dependency knows who uses it — implementations should never reference the code that injects
  them
- Inject fakes in tests — if testing requires hacking around private state or mocking imports,
  that's a signal to extract and inject instead
- Interfaces should be driven by the consumer, not the implementation — define what the caller
  needs, not what the dependency happens to offer

---
```