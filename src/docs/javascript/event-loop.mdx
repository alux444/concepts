---
title: Event Loop
description: Understanding the JavaScript event loop and how it handles asynchronous operations.
order: 4
---

## What is the event loop?

JS is a single-threaded language, so the event loop is how operations are handled without blocking.

1. **Call stack** - where synchronous code runs, one frame at a time
2. **Microtask queue** - for promises and other microtasks, runs after the current stack is empty
3. **Macrotask queue** - for timers, I/O, and other async tasks, e.g UI rendering

Flow: After the call stack empties, drain ALL microtasks, process ONE macrotask, then repeat.

```javascript
console.log("1 - synchronous");

setTimeout(() => {
  console.log("2 - macrotask (timer)");
}, 0);

Promise.resolve().then(() => {
  console.log("3 - microtask (promise)");
})

queueMicrotask(() => {
  console.log("4 - microtask (queueMicrotask)");
});

console.log("5 - synchronous");

// output:
// 1 - synchronous
// 5 - synchronous
// 3 - microtask (promise)
// 4 - microtask (queueMicrotask)
// 2 - macrotask (timer)

setTimeout(() => {
  console.log("1");
}, 0);

Promise.resolve()
  .then(() => {
    console.log("2");
    setTimeout(() => {
      console.log("3");
    }, 0);
  })
  .then(() => {
    console.log("4");
  });

Promise.resolve().then(() => {
  console.log("5");
});

console.log("6");

// output: 6, 2, 5, 4, 1, 3
``` 

Too many microtasks can starve the event loop and prevent macrotasks from running, causing issues like blocking UI rendering